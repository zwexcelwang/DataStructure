# 481-500

### 494. 目标和

给你一个整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

**难度系数：Medium**

#### 示例

```markdown
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3

```

#### 解

##### 我写的回溯，速度不是很快，可能是因为每次都传参太多了

```
class Solution {
    int time = 0;
    public int findTargetSumWays(int[] nums, int target) {
        backtrack(0, 0, nums, target);
        return time;
        
    }   

    private void backtrack(int t, int sum, int[] nums, int target){
        if(t >= nums.length){
            if(sum == target){
                time++;
            }         
        }else {            
                sum = sum - nums[t];
                backtrack(t+1, sum, nums, target);
                sum = sum + 2 * nums[t];
                backtrack(t+1, sum, nums, target);
        }

    }

}
```

##### 学习一下大佬写的

```
int findTargetSumWays(int[] nums, int target) {
    if (nums.length == 0) return 0;
    return dp(nums, 0, target);
}

// 备忘录
HashMap<String, Integer> memo = new HashMap<>();
int dp(int[] nums, int i, int rest) {
    // base case
    if (i == nums.length) {
        if (rest == 0) return 1;
        return 0;
    }
    // 把它俩转成字符串才能作为哈希表的键
    String key = i + "," + rest;
    // 避免重复计算
    if (memo.containsKey(key)) {
        return memo.get(key);
    }
    // 还是穷举
    int result = dp(nums, i + 1, rest - nums[i]) + dp(nums, i + 1, rest + nums[i]);
    // 记入备忘录
    memo.put(key, result);
    return result;
```

##### 动态规划：变成子集划分问题

有一部分前面的符号是+（这部分相加等于sumA），一部分前面的符号是-（这部分相加等于sumB）

$$ sumA - sumB = target $$

$$ sumA + sumB = sum $$

所以 $$ sumA -（sum - sumA） = target $$

所以 $$  2 * sumA = target + sum $$

所以最后转化成求这个子集A，背包问题嘛  $$  sumA = （target + sum） /  2 $$

状态转移方程：$$  dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];  $$

```
int findTargetSumWays(int[] nums, int target) {
    int sum = 0;
    for (int n : nums) sum += n;
    // 这两种情况，不可能存在合法的子集划分
    if (sum < target || (sum + target) % 2 == 1) {
        return 0;
    }
    return subsets(nums, (sum + target) / 2);
}
```

```
/* 计算 nums 中有几个子集的和为 sum */
int subsets(int[] nums, int sum) {
    int n = nums.length;
    int[][] dp = new int[n + 1][sum + 1];
    // base case
    for (int i = 0; i <= n; i++) {
        dp[i][0] = 1;
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= sum; j++) {
            if (j >= nums[i-1]) {
                // 两种选择的结果之和,因为求得是总方法
                dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];
            } else {
                // 背包的空间不足，只能选择不装物品 i
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    return dp[n][sum];
}
```

转化为一维dp，因为要保证dp[j]更新的时候都是外循环i-1时候的值，所有反着遍历

```
/* 计算 nums 中有几个子集的和为 sum */
int subsets(int[] nums, int sum) {
    int n = nums.length;
    int[] dp = new int[sum + 1];
    // base case
    dp[0] = 1;

    for (int i = 1; i <= n; i++) {
        // j 要从后往前遍历
        for (int j = sum; j >= 0; j--) {
            // 状态转移方程
            if (j >= nums[i-1]) {
                dp[j] = dp[j] + dp[j-nums[i-1]];
            } else {
                dp[j] = dp[j];
            }
        }
    }
    return dp[sum];
}
```



### 496. 下一个更大元素

给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。

请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。

nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。

**难度系数：Easy**

#### 示例

```markdown
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。
    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。
    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。

```

#### 解

##### 暴力解法  

我可能会被逐出计算机这一行

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int[] res;
        if(nums1 == null) {
            return null;
        }else {
            res = new int[nums1.length];
        }
        label: for(int i=0; i<nums1.length; i++) {
            res[i] = -1;
            int key = nums1[i];
            for(int j=0; j<nums2.length; j++){
                if(key == nums2[j] && j!=nums2.length-1) {
                   for(int m=j+1; m<nums2.length; m++) {
                       if(key < nums2[m]){
                           res[i] = nums2[m];
                           continue label;
                       }
                   }
                }
            }
        }
        return res;
    }
}
```

##### 单调栈

噢！这种特殊的数据结构真的好好用！！！（憨批发言）

```java
class Solution {

    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer, Integer> map = getNextGreat(nums2);
        int[] res = new int[nums1.length];
        for(int i=0; i<nums1.length; i++) {
            res[i] = map.getOrDefault(nums1[i], -1);
        }
        return res;
    }

    private Map<Integer, Integer> getNextGreat(int[] nums2) {
        Map<Integer, Integer> map = new HashMap<>();
        Stack<Integer> stack = new Stack<>();
        for(int i=0; i<nums2.length; i++) {
            while(!stack.empty() && stack.peek()<nums2[i]){
                int top = stack.pop();
                map.put(top, nums2[i]);
            }
            stack.push(nums2[i]);
        }
        return map;
    }
}
```



