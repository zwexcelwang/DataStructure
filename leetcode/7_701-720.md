# 701-720

### 704. 二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

**难度系数：Easy**

#### 示例

```markdown
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4

输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

#### 解

苍天呐！终于有了一个我会写的题

**左闭右闭：**

```java
class Solution {
    public int search(int[] nums, int target) {
        if(nums.length == 0){
            return -1;
        }
        int low = 0;
        int high = nums.length-1;
        while(low <= high){
            // int mid = (low + high) / 2;
            int mid = low + (high - low) / 2
            if(nums[mid] == target){
                 return mid;
            }else if(nums[mid] > target){
                high = mid - 1;
            }else{
            // }else if(nums[mid] < target){
            	// 写成这样是为了每种情况更清楚一点
                low = mid + 1;
            }
        }
        return -1;
    }
}
```

计算 mid 时需要防止溢出，代码中 `left + (right - left) / 2` 就和 `(left + right) / 2` 的结果相同，但是有效防止了 `left` 和 `right` 太大直接相加导致溢出。

**左闭右开：**

```java
class Solution {
    public int search(int[] nums, int target) {
        if(nums.length == 0){
            return -1;
        }
        int low = 0;
        int high = nums.length;
        while(low < high){
            int mid = low + (high - low) / 2
            if(nums[mid] == target){
                 return mid;
            }else if(nums[mid] > target){
                high = mid - 1;
            }else{
                low = mid + 1;
            }
        }
        // 在low=high的时候循环就终止了
        return nums[low] == target ? low : -1;
    }
}
```

上述算法的弊端就是如果target是重复的，不能准确的得到边界



**寻找左侧边界的二分：**

```java
public int searchLeftBound(int[] nums, int target) {
        if(nums.length == 0){
            return -1;
        }
        int low = 0;
        int high = nums.length;
        while(low < high){
            int mid = low + (high - low) / 2
            if(nums[mid] == target){
                 high = mid; //找到了不要立即返回，还需要再搜索左侧还有没有
            }else if(nums[mid] > target){
                high = mid;		// !!!
            }else{
                low = mid + 1;
            }
        }
    // target 比所有数都大
	if (low == nums.length) {
        return -1;
    }
    // 类似之前算法的处理方式
	return nums[low] == target ? low : -1;
}


public int searchLeftBound(int[] nums, int target) {
        if(nums.length == 0){
            return -1;
        }
        int low = 0;
        int high = nums.length-1;
        while(low <= high){
            int mid = low + (high - low) / 2
            if(nums[mid] == target){
                 high = mid-1; //找到了不要立即返回，还需要再搜索左侧还有没有
            }else if(nums[mid] > target){
                 high = mid -1;		// !!!
            }else{
                low = mid + 1;
            }
        }
    if (low >= nums.length || nums[low] != target){
    	return -1;
    }
	return low;
}
```



**寻找右侧边界的二分：**

```java
public int searchRightBound(int[] nums, int target) {
        if(nums.length == 0){
            return -1;
        }
        int low = 0;
        int high = nums.length;
        while(low < high){
            int mid = low + (high - low) / 2
            if(nums[mid] == target){
            	low = mid + 1;
            }else if(nums[mid] > target){
                high = mid - 1;		// !!!
            }else{
                low = mid + 1;
            }
        }
        if (low == 0) {
            return -1;
        }
        return nums[low-1] == target ? (low-1) : -1;
}


public int searchRightBound(int[] nums, int target) {
        if(nums.length == 0){
            return -1;
        }
        int low = 0;
        int high = nums.length-1;
        while(low <= high){
            int mid = low + (high - low) / 2
            if(nums[mid] == target){
                 low = mid + 1;
            }else if(nums[mid] > target){
                 high = mid - 1;	
            }else{
                 low = mid + 1;
            }
        }
	// 这里改为检查 high 越界的情况，见下图
    if (high < 0 || nums[high] != target)
        return -1;
    return high;
}
```



### 704. 最佳买卖股票时机含手续费

给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

**难度系数：Medium**

#### 示例

```markdown
输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8

输入：prices = [1,3,7,5,10,3], fee = 3
输出：6
```

#### 解

$dp[i][0] = max(dp[i-1][0], dp[i-1][1] + price[i])$

$dp[i][1] = max(dp[i-1][1], dp[i-1][0] - price[i] - fee)$

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int profit = 0;
        int len = prices.length;
        int dp_i_0 = 0;
        int dp_i_1 = Integer.MIN_VALUE;
        for (int i = 0; i < len; i++) {
            int temp = dp_i_0;
            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
            // 可以多次买入and卖出
            dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);
        }
        return dp_i_0;
    }
}
```



