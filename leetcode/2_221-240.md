# 221-240

### 222. 完全二叉树的节点个数

翻转一棵二叉树。给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。

完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

**难度系数：Medium**

#### 示例

```markown
输入：root = [1,2,3,4,5,6]
输出：6
```

#### 解

```java
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null){
            return 0;
        }
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```



### 226. 翻转二叉树

翻转一棵二叉树。

**难度系数：Easy**

#### 示例

```markown
输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1
```



#### 解

我应该会的

但是我以为我不会

但是我竟然真的会

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null) {
            return root;
        }
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```

### 230. 二叉搜索树中第K小的元素

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

**难度系数：Medium**

#### 示例

```markown
输入：root = [3,1,4,null,2], k = 1
输出：1
```

#### 解

不知道什么时候从别人那里学的方法

比如说你让我查找排名为`k`的元素，当前节点知道自己排名第`m`，那么我可以比较`m`和`k`的大小：

1、如果`m == k`，显然就是找到了第`k`个元素，返回当前节点就行了。

2、如果`k < m`，那说明排名第`k`的元素在左子树，所以可以去左子树搜索第`k`个元素。

3、如果`k > m`，那说明排名第`k`的元素在右子树，所以可以去右子树搜索第`k - m - 1`个元素。

这样就可以将时间复杂度降到`O(logN)`了。

```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        int leftCnt = count(root.left);
        if (leftCnt == k - 1) return root.val;
        if (leftCnt > k - 1) return kthSmallest(root.left, k);
        return kthSmallest(root.right, k - leftCnt - 1);
    }
    private int count(TreeNode node) {
        if (node == null) return 0;
        return 1 + count(node.left) + count(node.right);
    }
}
```

##### 看labuladong的公众号果然很有用，我会在递归里玩花样了

```java
class Solution {
    private int kthSmallestVal;
    private int th = 0;
    public int kthSmallest(TreeNode root, int k) {
        traverse(root, k);
        return kthSmallestVal;
    }
    private void traverse(TreeNode node, int k) {
        if (node == null) return;
        traverse(node.left, k);
        th = th+1;
        if(th == k){
             kthSmallestVal = node.val;
        }
        traverse(node.right, k);
    }
}
```

### 234. 回文链表

 给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。 

**难度系数：Easy**

#### 示例

```markown
输入：head = [1,2,2,1]
输出：true

输入：head = [1,2,2,1]
输出：true
```

#### 解

 **寻找**回文串的核心思想是从中心向两端扩展 

 **因为回文串是对称的，所以正着读和倒着读应该是一样的，这一特点是解决回文串问题的关键**。 

 单链表无法倒着遍历，无法使用双指针技巧。那么最简单的办法就是，把原始链表反转存入一条新的链表，然后比较这两条链表是否相同 

##### 官方题解， 递归解法（我不会写嘤嘤嘤）

```java
class Solution {

    private ListNode frontPointer;

    private boolean recursivelyCheck(ListNode currentNode) {
        if (currentNode != null) {
            if (!recursivelyCheck(currentNode.next)) {
                return false;
            }
            if (currentNode.val != frontPointer.val) {
                return false;
            }
            frontPointer = frontPointer.next;
        }
        return true;
    }

    public boolean isPalindrome(ListNode head) {
        frontPointer = head;
        return recursivelyCheck(head);
    }

}
```

##### 我也不知道什么时候写的

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null){
            return true;
        }
        ListNode newHead = new ListNode(-1);
        newHead.next = head;
        ListNode fast = newHead;
        ListNode slow = newHead;
		
        // 找中点
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
        }

        fast = slow.next;
        slow = head;

       	// 造一个反转过来的链表
        ListNode pre = null;
        while(fast != null){
            ListNode next = fast.next;
            fast.next = pre;
            pre = fast;
            fast = next;
        }
		
        // 比较值
        while(pre != null){
            if(pre.val != slow.val){
                return false;
            }
            pre = pre.next;
            slow = slow.next;
        }
        return true;

    }
}
```

